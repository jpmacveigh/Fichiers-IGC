<!DOCTYPE html>
<html>
	<head>
        <meta charset="utf-8">
		<!-- Nous chargeons les fichiers CDN de Leaflet. Le CSS AVANT le JS -->
		<link rel="stylesheet" href="https://unpkg.com/leaflet@1.6.0/dist/leaflet.css"
  		integrity="sha512-xwE/Az9zrjBIphAcBb3F6JVqxf46+CDLwfLMHloNu6KEQCAWi6HcDUbeOfBIptF7tcCzusKFjFw2yuvEpDL9wQ=="
  		crossorigin=""/>
  		<script src="https://unpkg.com/leaflet@1.6.0/dist/leaflet.js"
  		integrity="sha512-gZwIG9x3wUXg2hdXF6+rVkLF/0Vi9U8D2Ntg4Ga5I5BZpVkVxlJWbSQtXPSiUTtC0TjtGOmxa1AJPuV0CPthew=="
  		crossorigin=""></script>		
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
		<title>Trajectoire planeur</title>
		<style type="text/css">
			#map { /* la carte DOIT avoir une hauteur sinon elle n'apparaît pas */
				height:600px;
			}
		</style>
		<link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  		<link rel="stylesheet" href="leaflet-beautify-marker-icon.css">
  		<script src="leaflet-beautify-marker-icon.js"></script>
	</head>
	<body>
		<div id="map"></div>  <!-- Ici s'affichera la carte -->
	</body>
	<script type="text/javascript">
		// On initialise la latitude et la longitude de Lille (centre de la carte)
		var macarte = null;
		function initMap() {  // Fonction d'initialisation de la carte	
		    getTrajectoire_planeur_S3()   // lecture des points de la trajectoire à afficher
            .then(function(res){
            	console.log(res["points"].length);
				for (i=0;i<=(res["points"].length -1);i++){  // on transforme toutes les longitudes dans [0,360]
            		res["points"][i]["longi"]=longi_0_360(res["points"][i]["longi"]);
            	}
            	var latDernier=res["points"][res["points"].length -1]["lati"]
            	var lngDernier=res["points"][res["points"].length -1]["longi"]
            	macarte = L.map('map').setView([latDernier,lngDernier],14);  // Créer l'objet "macarte" et l'insèrer dans l'élément HTML qui a l'ID "map"
               	L.tileLayer('https://{s}.tile.openstreetmap.fr/osmfr/{z}/{x}/{y}.png', {  // Leaflet ne récupère pas les cartes (tiles) sur un serveur par défaut. Nous devons lui préciser où nous souhaitons les récupérer. Ici, openstreetmap.fr
                	attribution: 'données © <a href="//osm.org/copyright">OpenStreetMap</a>/ODbL - rendu <a href="//openstreetmap.fr">OSM France</a>',  // Il est toujours bien de laisser le lien vers la source des données
                	minZoom: 1,
                	maxZoom: 20
            	}).addTo(macarte);
            	var latlng=[];
            	var iconWidth=12;
            	var iconHight=iconWidth*1.5;
            	var iconsParameters = {     // paramètres communs à toutes les icones des Markers
            				iconUrl: "",
            				shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
            				iconSize: [iconWidth,iconHight],
						  			iconAnchor: [iconWidth/2.,iconHight],
						  			popupAnchor: [0,-iconHight],
						  			shadowSize: [iconHight,iconHight]
						  };
            	iconsParameters["iconUrl"]='https://cdn.rawgit.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-red.png';  // marker de couleur rouge
            	var redIcon = new L.Icon(iconsParameters);
		      	iconsParameters["iconUrl"]='https://cdn.rawgit.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-black.png';  // marker de couleur noire
				var blackIcon = new L.Icon(iconsParameters);
				iconsParameters["iconUrl"]='https://cdn.rawgit.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-blue.png';  // marker de couleur bleu
				var blueIcon = new L.Icon(iconsParameters);
            	for (var i=0;i<res["points"].length;i++){
            		latlng[i]=[res["points"][i]["lati"],res["points"][i]["longi"]];
            		var popup=new Date(res["points"][i]["ts"]*1000).toUTCString();
            		popup=popup +"<br>lat = "+res["points"][i]["lati"].toFixed(2)+"&nbsp &nbsp lon = "+res["points"][i]["longi"].toFixed(2);
            		popup=popup+"<br>hauteur : "+res["points"][i]["alti"].toFixed(0)+" m";
            		if (i>=1) {
            			var dist=macarte.distance(latlng[i],latlng[i-1]);
            			var deltat=res["points"][i]["ts"]-res["points"][i-1]["ts"];
            			var vitesse=dist/deltat*3600./1000.
            			popup=popup+"&nbsp &nbsp dist : "+dist.toFixed(0)+" m";
            			popup=popup+"<br>\u0394t : "+deltat.toFixed(0)+"sec. &nbsp &nbsp  vitesse : "+vitesse.toFixed(1)+" Km/h";
						popup=popup+"&nbsp &nbsp vz : "+res["points"][i]["vz"].toFixed(1)+" m/s";
					}
					if (res["points"][i]["isLift"] == "False") {    // si vz <= 0, marker bleu
						//L.marker([res["points"][i]["lati"],res["points"][i]["longi"]], {icon: blueIcon}).addTo(macarte).bindPopup(popup);
					}
					else {    // sinon, marker rouge
						//L.marker([res["points"][i]["lati"],res["points"][i]["longi"]], {icon: redIcon}).addTo(macarte).bindPopup(popup);
					}
			  	}
				var poly=L.polyline(latlng).addTo(macarte);   // afficahge du tracé de la trajectoire
				L.control.scale().addTo(macarte);
				console.log(res["ascendances"].length);
				for(var i=0;i<res["ascendances"].length;i++){
					console.log(i,res["ascendances"][i])
					var lati_centre=res["ascendances"][i]["lati_centre"];
					var longi_centre=res["ascendances"][i]["longi_centre"];
					var major_axis=res["ascendances"][i]["major_axis"];
					var minor_axis=res["ascendances"][i]["minor_axis"];
					console.log(major_axis,minor_axis);
					var rotation_angle=res["ascendances"][i]["rotation_angle"];
					//var ellipse = L.ellipse([50.7,3.07],[500, 300],45).addTo(macarte);
					//var ellipse = L.ellipse([lati_centre,longi_centre],[major_axis,minor_axis],rotation_angle).addTo(macarte);			
					var lesPoints=getPointsEllipse(longi_centre,lati_centre,major_axis,minor_axis,rotation_angle,300);
					console.log(lesPoints);
					L.polyline(lesPoints,{color:"red"}).addTo(macarte);  // tracé des points de l'ellipse
					//L.marker([lati_centre,longi_centre], {icon: redIcon}).addTo(macarte);	// ajout d'un marker au centre de l'ellipse			
					var popup="N° : "+i+"<br>"+res["ascendances"][i]["date_deb"]+"&nbsp à : "+res["ascendances"][i]["date_fin"]+"&nbsp durée: "+res["ascendances"][i]["duree"]+" sec";
					popup=popup+"<br>"+res["ascendances"][i]["alti_deb"] +" m &nbsp à : "+res["ascendances"][i]["alti_fin"] +" m &nbsp gain: "+res["ascendances"][i]["gain_alti"] +" m";
					popup=popup+"&nbsp vz: "+res["ascendances"][i]["vz_moy"].toFixed(1) +" m/s";
        			var options = {
            			isAlphaNumericIcon: true,
                		text: i,
                		iconShape: 'marker',
                		borderColor: '#00ABDC',
						textColor: '#00ABDC'	
					};
					L.marker([lati_centre,longi_centre], { icon: L.BeautifyIcon.icon(options), draggable: false }).addTo(macarte).bindPopup(popup);
				
				}
			})
            .catch(function(res){
				console.log("getTrajectoire s'est planté ! res :" + res);
				console.trace();
            });
        }
		window.onload = function(){	
			initMap(); // Fonction d'initialisation qui s'exécute lorsque le DOM est chargé
		};
		function getTrajectoire (){
			var res;
			var host=window.location.host;
			console.log (host);
			//var url = "https://node-jpmv-jpmv.c9users.io:8080/getTrajectoire"
			var url = "http://"+host+"/getTrajectoire";
			console.log(url);
			return new Promise(function(resolve,reject){
				$.ajax({  
					type: "GET",
					url: url,
					dataType: "json",
					async : true, 
					success: function (json){
						console.log("lecture getTrajectoire OK");
						resolve(json);
					},
					error: function(json){
						console.log("erreur lecture getTrajectoire");
						reject(json);
					}	
				});
			});	
		};
		function longi_0_360 (longitude){
			if (longitude >=0.) {
        		return (longitude);
			}
    		else {
        		return (360. -Math.abs(longitude));
    		}
		};
		function getTrajectoire_S3 (){
			var res;
			var host=window.location.host;
			console.log (host);
			//var url = "https://node-jpmv-jpmv.c9users.io:8080/getTrajectoire"
			//var url = "http://"+host+"/getTrajectoire";
			var url="https://2xqztty2x0.execute-api.eu-west-1.amazonaws.com/dev/test_S3"
			console.log(url);
			return new Promise(function(resolve,reject){
				$.ajax({  
					type: "GET",
					url: url,
					dataType: "json",
					async : true, 
					success: function (json){
						console.log("lecture getTrajectoire OK");
						resolve(json);
					},
					error: function(json){
						console.log("erreur lecture getTrajectoire");
						reject(json);
					}	
				});
			});	
		};
		function getTrajectoire_planeur_S3 (){
			var res;
			var host=window.location.host;
			console.log (host);
			//var url = "https://node-jpmv-jpmv.c9users.io:8080/getTrajectoire"
			//var url = "http://"+host+"/getTrajectoire";
			var url="https://1s69kcb1uf.execute-api.eu-west-1.amazonaws.com/prod/get_vol_planeur"
			console.log(url);
			return new Promise(function(resolve,reject){
				$.ajax({  
					type: "GET",
					url: url,
					dataType: "json",
					async : true, 
					success: function (json){
						console.log("lecture getTrajectoire_planeur_S3 OK");
						resolve(json);
					},
					error: function(json){
						console.log("erreur lecture getTrajectoire_planeur_S3");
						reject(json);
					}	
				});
			});	
		};
		
		function getPointsEllipse(longi_centre,lati_centre,major_axis,minor_axis,rotatio_angle,nb_points){
			// calcul des coordonnées des points d'une ellipse définie par la position de son centre,
			// ses demi grands et petits axes et son angle de rotation
			// ref : https://fr.wikipedia.org/wiki/Ellipse_(math%C3%A9matiques)
			var lesPoints=[];
			let cos_teta=Math.cos(rotatio_angle);
			let sin_teta=Math.sin(rotatio_angle);
			for (var i=0;i<nb_points;i++){
				let t=i*2*Math.PI/(nb_points-1);
				let cos_t= Math.cos(t);
				let sin_t= Math.sin(t);
				let longi=longi_centre + major_axis*cos_teta*cos_t - minor_axis*sin_teta*sin_t; // longitude du point
				let lati= lati_centre  + major_axis*sin_teta*cos_t + minor_axis*cos_teta*sin_t; // latitude du point
				lesPoints[i]=[lati,longi];	
			}
			return(lesPoints);
		};
		function sample_ellipse (ellipse, num_pts){
			var endpoint=true;
		}
		 
	</script>
</html>